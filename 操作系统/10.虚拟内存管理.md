## 物理内存管理
| 特点 |缺点|
|---- |----|
|源程序直接使用内存物理地址|容易访问冲突|
|程序必须全部装入内存才可运行|内存太小程序无法运行|
|程序占用连续的一片内存|产生内存碎片|
|多程序运行产生干扰|不安全|

## 改善物理内存管理的相关技术
- 内存拼接技术
- swapping
- overlay

## 虚拟内存管理的目标
- 小内存运行大程序
- 小内存运行多程序
- 多程序运行地址不冲突
- 内存利用效率高：无碎片，共享方便

## 虚拟内存实现思路
在程序运行时，只把当前必要的很小一部分代码和数据装入内存中，其余代码和数据有必要时再装入，不再运行的代码和数据及时从内存中删除。

## 典型虚拟内存管理方式
- 页式
- 段式
- 段页式

### 页式虚拟内存管理
把内存空间和进程空间划分为等大小的小片。
- 小片的典型大小：1K、2K、4K...
- 进程小片：页
- 内存小片：页框

#### 地址映射
页面大小S，页号P，页框号P'，偏移地址w  
- 虚拟地址：VA = P*S + W
- 物理地址：PA = P‘*S + W

根据以上公式，配合页面映射表，即可将虚拟地址转化为物理地址

#### 快表
存放在cache的页表，用于提高地址映射速度

#### 共享
在不同进程的页表中填上相同的页框号，多个进程能访问相同的内存空间，从而实现内存共享。

#### 缺页中断
在地址映射过程中，若访问的页不在内存中，则系统产生异常中断---却页中断

#### 页面淘汰
- OPT
- FIFO
- LRU
- LFU

#### 缺页因素
- 淘汰算法
- 分配给进程的页框数
- 页本身的大小
1. 页面太大：浪费内存，极限是分区存储
2. 页面太小：页面增加，页表长度增加，浪费内存；换页频繁，系统效率低\\

### 页式 vs 段式
#### 地址空间
- 页式：一维
- 段式：二维

#### 区别
- 段长可变
- 段的划分有意义
- 段方便共享
- 段用户可见
- 段偏移有溢出

### 段页式



